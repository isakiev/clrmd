using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.InteropServices;

namespace Microsoft.Diagnostics.Runtime.ICorDebug
{
  // Wrapper for ICLRMetaHost.  Used to find information about runtimes.
  internal sealed class CLRMetaHost
  {
    private readonly ICLRMetaHost m_metaHost;

    public const int MaxVersionStringLength = 26; // 24 + NULL and an extra
    private static readonly Guid clsidCLRMetaHost = new Guid("9280188D-0E8E-4867-B30C-7FA83884E8DE");

    public CLRMetaHost()
    {
      object o;
      var ifaceId = typeof(ICLRMetaHost).GetGuid();
      var clsid = clsidCLRMetaHost;
      NativeMethods.CLRCreateInstance(ref clsid, ref ifaceId, out o);
      m_metaHost = (ICLRMetaHost)o;
    }

    public CLRRuntimeInfo GetInstalledRuntimeByVersion(string version)
    {
      var runtimes = EnumerateInstalledRuntimes();

      foreach (var rti in runtimes)
        if (rti.GetVersionString().ToLower() == version.ToLower())
          return rti;

      return null;
    }

    public CLRRuntimeInfo GetLoadedRuntimeByVersion(int processId, string version)
    {
      var runtimes = EnumerateLoadedRuntimes(processId);

      foreach (var rti in runtimes)
        if (rti.GetVersionString().Equals(version, StringComparison.OrdinalIgnoreCase))
          return rti;

      return null;
    }

    // Retrieve information about runtimes installed on the machine (i.e. in %WINDIR%\Microsoft.NET\)
    public IEnumerable<CLRRuntimeInfo> EnumerateInstalledRuntimes()
    {
      var runtimes = new List<CLRRuntimeInfo>();
      var enumRuntimes = m_metaHost.EnumerateInstalledRuntimes();

      // Since we're only getting one at a time, we can pass NULL for count.
      // S_OK also means we got the single element we asked for.
      for (object oIUnknown; enumRuntimes.Next(1, out oIUnknown, IntPtr.Zero) == 0; /* empty */) runtimes.Add(new CLRRuntimeInfo(oIUnknown));

      return runtimes;
    }

    // Retrieve information about runtimes that are currently loaded into the target process.
    public IEnumerable<CLRRuntimeInfo> EnumerateLoadedRuntimes(int processId)
    {
      var runtimes = new List<CLRRuntimeInfo>();
      IEnumUnknown enumRuntimes;

      using (var hProcess = NativeMethods.OpenProcess(
        /*
        (int)(NativeMethods.ProcessAccessOptions.ProcessVMRead |
                                                                NativeMethods.ProcessAccessOptions.ProcessQueryInformation |
                                                                NativeMethods.ProcessAccessOptions.ProcessDupHandle |
                                                                NativeMethods.ProcessAccessOptions.Synchronize),
         **/
        // TODO FIX NOW for debugging. 
        0x1FFFFF, // PROCESS_ALL_ACCESS
        false, // inherit handle
        processId))
      {
        if (hProcess.IsInvalid) throw new Win32Exception(Marshal.GetLastWin32Error());

        enumRuntimes = m_metaHost.EnumerateLoadedRuntimes(hProcess);
      }

      // Since we're only getting one at a time, we can pass NULL for count.
      // S_OK also means we got the single element we asked for.
      for (object oIUnknown; enumRuntimes.Next(1, out oIUnknown, IntPtr.Zero) == 0; /* empty */) runtimes.Add(new CLRRuntimeInfo(oIUnknown));

      return runtimes;
    }

    public CLRRuntimeInfo GetRuntime(string version)
    {
      var ifaceId = typeof(ICLRRuntimeInfo).GetGuid();
      return new CLRRuntimeInfo(m_metaHost.GetRuntime(version, ref ifaceId));
    }
  }
}